<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VIB3CODE | JSON-Configurable Tesseract Navigation</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=JetBrains+Mono:wght@400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: white;
            font-family: 'Orbitron', 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
            cursor: crosshair;
            background: radial-gradient(ellipse at center, #1a0033 0%, #000000 70%);
        }
        
        /* REACTIVE HYPERAV BACKGROUND */
        #reactive-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 1;
            opacity: 0.9;
        }
        
        /* TESSERACT 8-CELL HYPERCUBE CONTAINER */
        .tesseract-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            perspective: 2000px;
            perspective-origin: center center;
            overflow: hidden;
            z-index: 10;
            
            /* Advanced CSS Variables for Real-time Reactivity */
            --global-energy: 0.0;
            --section-focus: 0;
            --portal-intensity: 0.0;
            --micro-chaos: 0.0;
            --inverse-flow: 0.0;
            --grid-vibrance: 1.0;
            --transition-phase: 0.0;
            --hover-section: -1;
            --scroll-momentum: 0.0;
            --reality-tear: 0.0;
            
            /* Smart Opacity Variables */
            --visualizer-opacity: 0.8;
            --focused-opacity: 0.9;
            --reading-opacity: 0.7;
            --gravity-opacity: 0.8;
            --board-opacity: 0.7;
            
            /* Content Guidance Variables */
            --content-gravity-x: 0.5;
            --content-gravity-y: 0.5;
            --content-flow-strength: 0.0;
            --text-proximity: 0.0;
        }
        
        /* SINGLE DYNAMIC FACE WITH 8 GEOMETRY STATES */
        .hypercube-face {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            backface-visibility: visible;
            transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        .hypercube-face.active-face {
            transform: translateZ(0px);
            opacity: 1;
            visibility: visible;
        }
        
        /* GEOMETRY-BASED DYNAMIC STATES */
        .active-face[data-geometry="hypercube"] { /* HOME STATE - FRONT */
            /* Hypercube sovereignty layout */
        }
        
        .active-face[data-geometry="tetrahedron"] { /* TECH STATE - RIGHT */
            /* Tetrahedron precision layout */
        }
        
        .active-face[data-geometry="wave"] { /* RESEARCH STATE - BACK */
            /* Wave function layout */
        }
        
        .active-face[data-geometry="sphere"] { /* MEDIA STATE - LEFT */
            /* Sphere potential layout */
        }
        
        .active-face[data-geometry="fractal"] { /* INNOVATION STATE - TOP */
            /* Fractal growth layout */
        }
        
        .active-face[data-geometry="crystal"] { /* CONTEXT STATE - BOTTOM */
            /* Crystal lattice layout */
        }
        
        .active-face[data-geometry="klein"] { /* KLEIN STATE - INNER FRONT */
            /* Klein bottle topology layout */
        }
        
        .active-face[data-geometry="torus"] { /* TORUS STATE - INNER BACK */
            /* Torus flow layout */
        }
        
        /* TESSERACT FOLDING STATES */
        .tesseract-container.folding-right .hypercube-face.face-0 {
            transform: rotateY(-90deg) translateZ(-100px);
        }
        
        .tesseract-container.folding-right .hypercube-face.face-1 {
            transform: rotateY(0deg) translateZ(0px);
        }
        
        .tesseract-container.folding-left .hypercube-face.face-0 {
            transform: rotateY(90deg) translateZ(-100px);
        }
        
        .tesseract-container.folding-left .hypercube-face.face-3 {
            transform: rotateY(0deg) translateZ(0px);
        }
        
        .tesseract-container.folding-up .hypercube-face.face-0 {
            transform: rotateX(90deg) translateZ(-100px);
        }
        
        .tesseract-container.folding-up .hypercube-face.face-4 {
            transform: rotateX(0deg) translateZ(0px);
        }
        
        .tesseract-container.folding-down .hypercube-face.face-0 {
            transform: rotateX(-90deg) translateZ(-100px);
        }
        
        .tesseract-container.folding-down .hypercube-face.face-5 {
            transform: rotateX(0deg) translateZ(0px);
        }
        
        /* HYPERCUBE TENSION MECHANICS */
        .tesseract-container.tension-building {
            --tension-intensity: 0.0;
            filter: blur(calc(var(--tension-intensity) * 2px));
        }
        
        .tesseract-container.tension-building .hypercube-face {
            transform: scale(calc(1.0 + var(--tension-intensity) * 0.05)) 
                      rotateZ(calc(var(--tension-intensity) * 2deg));
        }
        
        /* MAIN BLOG CONTAINER */
        .blog-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 20px;
            padding: 40px;
            box-sizing: border-box;
        }
        
        /* JSON-CONFIGURABLE BLOG CARDS */
        .blog-card {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            cursor: pointer;
            display: flex;
            flex-direction: column;
        }
        
        .blog-card:hover {
            border-color: rgba(255, 255, 255, 0.6);
            transform: scale(1.05);
            background: rgba(0, 0, 0, 0.95);
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
            z-index: 100;
        }
        
        /* Systematic feedback - unfocused cards react */
        .blog-container:hover .blog-card:not(:hover) {
            opacity: 0.6;
            transform: scale(0.98);
            border-color: rgba(255, 255, 255, 0.05);
        }
        
        .card-content {
            flex: 1;
            overflow-y: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        
        .card-content::-webkit-scrollbar {
            width: 0;
            display: none;
        }
        
        .dynamic-content-block {
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }
        
        .card-title, .blog-title {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .card-subtitle {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 15px;
        }
        
        .article-content {
            line-height: 1.4;
            opacity: 0.9;
        }
        
        .card h3 {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .card p {
            font-size: 0.9em;
            line-height: 1.4;
            opacity: 0.9;
        }
        
        /* CONTROL PANELS */
        .dev-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(20px);
            z-index: 1000;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .dev-controls button {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #00ffff;
            padding: 5px 10px;
            margin: 2px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.3s ease;
        }
        
        .dev-controls button:hover {
            background: rgba(0, 255, 255, 0.3);
            border-color: rgba(0, 255, 255, 1.0);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .parameter-display {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 0, 255, 0.3);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(20px);
            z-index: 1000;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            min-width: 200px;
        }
        
        .param-row {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
            color: #ff00ff;
        }
        
        .param-value {
            color: #00ffff;
            font-weight: bold;
        }
        
        /* Theme-specific colors from JSON */
        .theme-hypercube .card:hover { border-color: rgba(255, 0, 255, 1.0); box-shadow: 0 0 30px rgba(255, 0, 255, 0.5); }
        .theme-tetrahedron .card:hover { border-color: rgba(0, 255, 255, 1.0); box-shadow: 0 0 30px rgba(0, 255, 255, 0.5); }
        .theme-sphere .card:hover { border-color: rgba(255, 255, 0, 1.0); box-shadow: 0 0 30px rgba(255, 255, 0, 0.5); }
        .theme-torus .card:hover { border-color: rgba(0, 255, 0, 1.0); box-shadow: 0 0 30px rgba(0, 255, 0, 0.5); }
        
        /* Loading screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: opacity 0.5s ease;
        }
        
        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-text {
            font-size: 2em;
            color: #00ffff;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
        }
        
        .loading-progress {
            width: 300px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff00ff, #00ffff);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-text">🎯 VIB3CODE</div>
        <div class="loading-text" style="font-size: 0.8em;">Initializing JSON-Configurable System...</div>
        <div class="loading-progress">
            <div class="loading-bar" id="loadingBar"></div>
        </div>
    </div>

    <!-- Reactive HyperAV Background -->
    <canvas id="reactive-canvas"></canvas>
    
    <!-- Parameter Display -->
    <div class="parameter-display" id="parameterDisplay">
        <div style="color: #ff00ff; font-weight: bold; margin-bottom: 8px;">📊 SYSTEM PARAMETERS</div>
        <div class="param-row">
            <span>Section:</span>
            <span class="param-value" id="currentSection">HOME</span>
        </div>
        <div class="param-row">
            <span>Theme:</span>
            <span class="param-value" id="currentTheme">hypercube</span>
        </div>
        <div class="param-row">
            <span>Dimension:</span>
            <span class="param-value" id="currentDimension">3.5</span>
        </div>
        <div class="param-row">
            <span>Grid:</span>
            <span class="param-value" id="currentGrid">12.0</span>
        </div>
        <div class="param-row">
            <span>Morph:</span>
            <span class="param-value" id="currentMorph">0.5</span>
        </div>
        <div class="param-row">
            <span>Intensity:</span>
            <span class="param-value" id="currentIntensity">0.0</span>
        </div>
    </div>
    
    <!-- Dev Controls -->
    <div class="dev-controls">
        <div style="color: #00ffff; font-weight: bold; margin-bottom: 8px;">🔧 DEV CONTROLS</div>
        <button onclick="devControls.applyPreset('reset')">Reset</button>
        <button onclick="devControls.applyPreset('highEnergy')">High Energy</button>
        <button onclick="devControls.applyPreset('calmSphere')">Calm</button>
        <button onclick="devControls.applyPreset('maximum')">Maximum</button>
        <br>
        <button onclick="devControls.cycleSection()">Cycle Section</button>
        <button onclick="devControls.testParameterChange()">Test Change</button>
        <div style="margin-top: 8px; font-size: 8px; color: #666;">
            D=Toggle | Space=Cycle | R=Reset
        </div>
    </div>
    
    <!-- Tesseract Navigation Container -->
    <div class="tesseract-container" id="tesseractContainer">
        <!-- Single Dynamic Face with 8 Geometry States -->
        <div class="hypercube-face active-face" id="dynamic-face" data-geometry="hypercube" data-face="0">
            <div class="blog-container">
                <!-- Cards will be populated by JSON -->
                <div class="blog-card" id="card-1">
                    <div class="card-content">
                        <!-- Dynamic content from JSON -->
                    </div>
                </div>
                <div class="blog-card" id="card-2">
                    <div class="card-content">
                        <!-- Dynamic content from JSON -->
                    </div>
                </div>
                <div class="blog-card" id="card-3">
                    <div class="card-content">
                        <!-- Dynamic content from JSON -->
                    </div>
                </div>
                <div class="blog-card" id="card-4">
                    <div class="card-content">
                        <!-- Dynamic content from JSON -->
                    </div>
                </div>
                <div class="blog-card" id="card-5">
                    <div class="card-content">
                        <!-- Dynamic content from JSON -->
                    </div>
                </div>
                <div class="blog-card" id="card-6">
                    <div class="card-content">
                        <!-- Dynamic content from JSON -->
                    </div>
                </div>
                <div class="blog-card" id="card-7">
                    <div class="card-content">
                        <!-- Dynamic content from JSON -->
                    </div>
                </div>
                <div class="blog-card" id="card-8">
                    <div class="card-content">
                        <!-- Dynamic content from JSON -->
                    </div>
                </div>
                <div class="blog-card" id="card-9">
                    <div class="card-content">
                        <!-- Dynamic content from JSON -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Core Systems -->
    <script src="VIB3_JSON_CONFIG_SYSTEM.js"></script>
    <script src="VIB3_REACTIVE_HYPERAV_CORE.js"></script>

    <script>
        /**
         * VIB3 TESSERACT NAVIGATION SYSTEM
         * 
         * Sophisticated navigation system based on the refined morphing-blog architecture
         * Integrates JSON configuration with advanced tesseract container and DualNavigationSystem
         * Implements VIB3HomeMaster parameter authority and multi-layer ReactiveHyperAVCore
         */
        
        class VIB3TesseractSystem {
            constructor() {
                this.configSystem = null;
                this.hyperavCore = null;
                this.dualNavigationSystem = null;
                this.currentGeometry = 'hypercube';
                this.currentFace = 0;
                this.isInitialized = false;
                
                // Tesseract geometry mapping from refined architecture
                this.geometryStates = [
                    'hypercube',    // Face 0 - HOME (FRONT)
                    'tetrahedron',  // Face 1 - TECH (RIGHT)
                    'wave',         // Face 2 - RESEARCH (BACK)
                    'sphere',       // Face 3 - MEDIA (LEFT)
                    'fractal',      // Face 4 - INNOVATION (TOP)
                    'crystal',      // Face 5 - CONTEXT (BOTTOM)
                    'klein',        // Face 6 - INNER FRONT
                    'torus'         // Face 7 - INNER BACK
                ];
                
                // Mathematical relationships from sophisticated architecture
                this.sectionModifiers = {
                    'HOME': { geometryThemeName: 'hypercube', name: 'HOME', multiplier: 1.0 },
                    'TECH': { geometryThemeName: 'tetrahedron', name: 'TECH', multiplier: 0.91 },
                    'RESEARCH': { geometryThemeName: 'wave', name: 'RESEARCH', multiplier: 1.15 },
                    'MEDIA': { geometryThemeName: 'sphere', name: 'MEDIA', multiplier: 1.08 },
                    'INNOVATION': { geometryThemeName: 'fractal', name: 'INNOVATION', multiplier: 1.22 },
                    'CONTEXT': { geometryThemeName: 'crystal', name: 'CONTEXT', multiplier: 0.88 },
                    'KLEIN': { geometryThemeName: 'klein', name: 'KLEIN', multiplier: 1.11 },
                    'TORUS': { geometryThemeName: 'torus', name: 'TORUS', multiplier: 1.03 }
                };
                
                console.log('🚀 VIB3 Tesseract System initializing...');
                this.init();
            }
            
            async init() {
                try {
                    // Update loading progress
                    this.updateLoadingProgress(20, 'Loading JSON configurations...');
                    
                    // Initialize JSON config system
                    this.configSystem = new VIB3JsonConfigSystem();
                    await this.configSystem.loadAllConfigs();
                    
                    this.updateLoadingProgress(40, 'Initializing WebGL core...');
                    
                    // Setup WebGL canvas
                    const canvas = document.getElementById('reactive-canvas');
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    
                    // Initialize HyperAV core
                    this.hyperavCore = new VIB3ReactiveHyperAVCore(canvas, this, this);
                    
                    this.updateLoadingProgress(60, 'Building tesseract interface...');
                    
                    // Initialize DualNavigationSystem
                    this.initializeDualNavigationSystem();
                    
                    // Build dynamic content from JSON
                    this.buildDynamicContentFromJSON();
                    
                    this.updateLoadingProgress(80, 'Setting up advanced interactions...');
                    
                    // Setup sophisticated interactions
                    this.setupTesseractInteractions();
                    this.setupBezelNavigation();
                    this.setupKeyboardControls();
                    
                    this.updateLoadingProgress(100, 'System ready!');
                    
                    // Hide loading screen
                    setTimeout(() => {
                        document.getElementById('loadingScreen').classList.add('hidden');
                        this.isInitialized = true;
                        console.log('✅ VIB3 Working System fully initialized');
                    }, 500);
                    
                } catch (error) {
                    console.error('❌ Failed to initialize VIB3 system:', error);
                    this.updateLoadingProgress(0, 'Initialization failed');
                }
            }
            
            updateLoadingProgress(percent, text) {
                const bar = document.getElementById('loadingBar');
                const screen = document.getElementById('loadingScreen');
                
                if (bar) bar.style.width = percent + '%';
                if (screen) {
                    const textElement = screen.querySelector('.loading-text:last-of-type');
                    if (textElement) textElement.textContent = text;
                }
            }
            
            initializeDualNavigationSystem() {
                // Initialize sophisticated navigation system from refined architecture
                this.dualNavigationSystem = {
                    tesseractContainer: document.getElementById('tesseractContainer'),
                    dynamicFace: document.getElementById('dynamic-face'),
                    currentFace: 0,
                    isTransitioning: false,
                    isDragging: false,
                    tensionLevel: 0,
                    config: {
                        navigationParameters: {
                            dragSensitivity: { value: 0.8 },
                            bezelWidth: { value: 80 },
                            tensionThreshold: { value: 150 },
                            snapStrength: { value: 0.7 }
                        }
                    }
                };
                
                console.log('🎲 DualNavigationSystem initialized with tesseract container');
            }
            
            buildDynamicContentFromJSON() {
                // Build dynamic content system like the sophisticated morphing blog
                const sections = this.configSystem.getConfig('content', 'sections');
                
                if (!sections || !Array.isArray(sections)) {
                    console.error('Invalid sections data in JSON config');
                    return;
                }
                
                // Start with HOME geometry (hypercube)
                this.updateDynamicFaceContent(0);
                
                console.log('🏗️ Dynamic content system built from JSON configuration');
            }
            
            updateDynamicFaceContent(faceIndex) {
                // Sophisticated content update from refined architecture
                const geometryName = this.geometryStates[faceIndex] || this.geometryStates[0];
                
                if (!this.dualNavigationSystem.dynamicFace) {
                    console.warn('Dynamic face not found');
                    return;
                }
                
                console.log(`🔄 DYNAMIC CONTENT: Switching to ${geometryName} (face ${faceIndex})`);
                
                this.dualNavigationSystem.dynamicFace.setAttribute('data-geometry', geometryName);
                this.dualNavigationSystem.dynamicFace.setAttribute('data-face', faceIndex.toString());
                
                this.renderDynamicContentForSection(geometryName);
                
                const blogContainer = this.dualNavigationSystem.dynamicFace.querySelector('.blog-container');
                if (blogContainer) {
                    // Remove old layout classes
                    this.geometryStates.forEach(geom => blogContainer.classList.remove(`layout-${geom}`));
                    // Add new layout class
                    blogContainer.classList.add(`layout-${geometryName}`);
                }
                
                // Update current state
                this.currentGeometry = geometryName;
                this.currentFace = faceIndex;
                
                // Trigger geometry change in visualizers
                this.triggerGeometryChange(geometryName, faceIndex);
            }
            
            renderDynamicContentForSection(geometryName) {
                // Render content based on JSON configuration like sophisticated system
                const sections = this.configSystem.getConfig('content', 'sections');
                if (!sections) {
                    console.warn('No sections data available');
                    return;
                }
                
                // Find target section by geometry name
                let targetSection = null;
                for (const [key, modifier] of Object.entries(this.sectionModifiers)) {
                    if (modifier.geometryThemeName === geometryName) {
                        targetSection = sections.find(s => s.name === modifier.name);
                        break;
                    }
                }
                
                if (!targetSection || !targetSection.content) {
                    console.warn(`No content found for geometry: ${geometryName}`);
                    return;
                }
                
                // Clear all existing card content
                document.querySelectorAll('#dynamic-face .blog-card .card-content').forEach(container => {
                    container.innerHTML = '';
                });
                
                // Populate cards with section content
                targetSection.content.forEach((cardData, index) => {
                    const cardElement = document.getElementById(`card-${index + 1}`);
                    if (!cardElement) return;
                    
                    const contentContainer = cardElement.querySelector('.card-content');
                    if (!contentContainer) return;
                    
                    // Create title
                    const title = document.createElement('div');
                    title.className = 'card-title';
                    title.textContent = cardData.title;
                    contentContainer.appendChild(title);
                    
                    // Create content
                    const content = document.createElement('div');
                    content.className = 'article-content';
                    content.textContent = cardData.content;
                    contentContainer.appendChild(content);
                    
                    // Setup systematic reactivity
                    if (cardData.reactivity) {
                        this.setupCardReactivity(cardElement, cardData.reactivity);
                    }
                });
            }
            
            setupCardReactivity(card, reactivityConfig) {
                // Card hover triggers parameter changes from JSON
                card.addEventListener('mouseenter', () => {
                    if (reactivityConfig.parameterChanges && this.hyperavCore) {
                        // Apply parameter changes from JSON
                        this.hyperavCore.updateParameters(reactivityConfig.parameterChanges);
                        
                        // Update parameter display
                        this.updateParameterDisplay();
                        
                        // Trigger systematic feedback - other cards react
                        this.triggerSystematicFeedback(card, reactivityConfig);
                    }
                });
                
                card.addEventListener('mouseleave', () => {
                    // Return to theme defaults
                    if (this.hyperavCore) {
                        const currentThemeConfig = this.hyperavCore.themeConfigs[this.currentTheme];
                        if (currentThemeConfig) {
                            this.hyperavCore.updateParameters(currentThemeConfig);
                            this.updateParameterDisplay();
                        }
                    }
                });
                
                // Click for dramatic effect
                card.addEventListener('click', () => {
                    if (reactivityConfig.parameterChanges && this.hyperavCore) {
                        // Apply dramatic multiplier
                        const dramaticParams = {};
                        Object.entries(reactivityConfig.parameterChanges).forEach(([key, value]) => {
                            dramaticParams[key] = value * 1.5; // 1.5x for click
                        });
                        
                        this.hyperavCore.updateParameters(dramaticParams);
                        this.hyperavCore.updateInteractionState('dramatic-click', 1.0);
                        
                        // Return to normal after 1 second
                        setTimeout(() => {
                            const currentThemeConfig = this.hyperavCore.themeConfigs[this.currentTheme];
                            if (currentThemeConfig) {
                                this.hyperavCore.updateParameters(currentThemeConfig);
                                this.updateParameterDisplay();
                            }
                        }, 1000);
                    }
                });
            }
            
            triggerSystematicFeedback(focusedCard, reactivityConfig) {
                // Systematic feedback - unfocused elements react
                const allCards = document.querySelectorAll('.card');
                const behaviorConfig = this.configSystem.getConfig('behavior', 'systematicFeedback');
                
                if (behaviorConfig && behaviorConfig.enabled) {
                    allCards.forEach(card => {
                        if (card !== focusedCard) {
                            // Apply unfocused effect
                            card.style.opacity = behaviorConfig.rules.focusResponse.unfocusedReduction || 0.6;
                            card.style.transform = 'scale(0.98)';
                        }
                    });
                }
            }
            
            setupTesseractInteractions() {
                // Advanced tesseract folding interactions from sophisticated architecture
                const container = this.dualNavigationSystem.tesseractContainer;
                
                // Mouse/touch drag interactions
                container.addEventListener('mousedown', (e) => this.startDrag(e));
                container.addEventListener('touchstart', (e) => this.startDrag(e), { passive: false });
                
                document.addEventListener('mousemove', (e) => this.handleDrag(e));
                document.addEventListener('touchmove', (e) => this.handleDrag(e), { passive: false });
                
                document.addEventListener('mouseup', () => this.endDrag());
                document.addEventListener('touchend', () => this.endDrag());
                
                console.log('🎲 Tesseract interactions initialized');
            }
            
            setupBezelNavigation() {
                // Bezel-based navigation from sophisticated architecture
                const bezelConfig = this.dualNavigationSystem.config.navigationParameters;
                
                // Edge detection for navigation
                document.addEventListener('mousemove', (e) => {
                    if (this.isNearBezel(e.clientX, e.clientY)) {
                        document.body.style.cursor = 'grab';
                    } else {
                        document.body.style.cursor = 'crosshair';
                    }
                });
                
                console.log('📱 Bezel navigation initialized');
            }
            
            isNearBezel(x, y) {
                const bezelW = this.dualNavigationSystem.config.navigationParameters.bezelWidth.value;
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                
                return (x < bezelW || x > windowWidth - bezelW ||
                        y < bezelW || y > windowHeight - bezelW);
            }
            
            startDrag(e) {
                if (this.dualNavigationSystem.isTransitioning || !e) return;
                
                this.dualNavigationSystem.isDragging = true;
                this.dualNavigationSystem.startX = e.clientX || e.touches[0].clientX;
                this.dualNavigationSystem.startY = e.clientY || e.touches[0].clientY;
                this.dualNavigationSystem.tensionLevel = 0;
                
                this.dualNavigationSystem.isBezelDrag = this.isNearBezel(
                    this.dualNavigationSystem.startX, 
                    this.dualNavigationSystem.startY
                );
                
                this.dualNavigationSystem.tesseractContainer.style.cursor = 'grabbing';
                document.body.style.userSelect = 'none';
                
                console.log(`🎲 Drag started - Bezel mode: ${this.dualNavigationSystem.isBezelDrag}`);
            }
            
            handleDrag(e) {
                if (!this.dualNavigationSystem.isDragging || this.dualNavigationSystem.isTransitioning) return;
                
                e.preventDefault();
                
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                
                const deltaX = (clientX - this.dualNavigationSystem.startX) * 
                              this.dualNavigationSystem.config.navigationParameters.dragSensitivity.value;
                const deltaY = (clientY - this.dualNavigationSystem.startY) * 
                              this.dualNavigationSystem.config.navigationParameters.dragSensitivity.value;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                // Build tension
                const threshold = this.dualNavigationSystem.config.navigationParameters.tensionThreshold.value;
                this.dualNavigationSystem.tensionLevel = Math.min(distance / threshold, 1.0);
                
                // Apply tension visual effects
                this.dualNavigationSystem.tesseractContainer.style.setProperty(
                    '--tension-intensity', 
                    this.dualNavigationSystem.tensionLevel
                );
                
                if (this.dualNavigationSystem.tensionLevel > 0.3) {
                    this.dualNavigationSystem.tesseractContainer.classList.add('tension-building');
                }
                
                // Determine navigation direction
                if (distance > threshold) {
                    const angle = Math.atan2(deltaY, deltaX);
                    this.determineNavigationDirection(angle);
                }
            }
            
            endDrag() {
                if (!this.dualNavigationSystem.isDragging) return;
                
                this.dualNavigationSystem.isDragging = false;
                this.dualNavigationSystem.tesseractContainer.style.cursor = 'crosshair';
                document.body.style.userSelect = '';
                
                // Reset tension
                this.dualNavigationSystem.tesseractContainer.classList.remove('tension-building');
                this.dualNavigationSystem.tesseractContainer.style.setProperty('--tension-intensity', '0');
                
                console.log('🎲 Drag ended');
            }
            
            determineNavigationDirection(angle) {
                // Convert angle to navigation direction
                const degrees = (angle * 180 / Math.PI + 360) % 360;
                
                let targetFace = this.currentFace;
                
                if (degrees >= 315 || degrees < 45) { // Right
                    targetFace = 1; // TECH
                } else if (degrees >= 45 && degrees < 135) { // Down
                    targetFace = 5; // CONTEXT
                } else if (degrees >= 135 && degrees < 225) { // Left
                    targetFace = 3; // MEDIA
                } else if (degrees >= 225 && degrees < 315) { // Up
                    targetFace = 4; // INNOVATION
                }
                
                if (targetFace !== this.currentFace) {
                    this.navigateToFace(targetFace);
                }
            }
            
            setupKeyboardControls() {
                document.addEventListener('keydown', (e) => {
                    if (!this.isInitialized) return;
                    
                    switch(e.key) {
                        case 'd':
                        case 'D':
                            this.toggleDevMode();
                            break;
                        case ' ':
                            e.preventDefault();
                            this.cycleFace();
                            break;
                        case 'r':
                        case 'R':
                            this.applyPreset('reset');
                            break;
                        case 'ArrowRight':
                            this.navigateToFace(1); // TECH
                            break;
                        case 'ArrowLeft':
                            this.navigateToFace(3); // MEDIA
                            break;
                        case 'ArrowUp':
                            this.navigateToFace(4); // INNOVATION
                            break;
                        case 'ArrowDown':
                            this.navigateToFace(5); // CONTEXT
                            break;
                    }
                });
            }
            
            navigateToFace(faceIndex) {
                if (faceIndex === this.currentFace || this.dualNavigationSystem.isTransitioning) return;
                
                this.dualNavigationSystem.isTransitioning = true;
                
                // Apply tesseract folding animation
                const container = this.dualNavigationSystem.tesseractContainer;
                
                const foldingClasses = {
                    1: 'folding-right',
                    2: 'folding-back',
                    3: 'folding-left', 
                    4: 'folding-up',
                    5: 'folding-down',
                    6: 'folding-inner-front',
                    7: 'folding-inner-back'
                };
                
                // Remove all folding classes
                Object.values(foldingClasses).forEach(cls => container.classList.remove(cls));
                
                // Add appropriate folding class
                if (foldingClasses[faceIndex]) {
                    container.classList.add(foldingClasses[faceIndex]);
                }
                
                // Update content after folding animation
                setTimeout(() => {
                    this.updateDynamicFaceContent(faceIndex);
                    
                    // Reset folding state
                    setTimeout(() => {
                        Object.values(foldingClasses).forEach(cls => container.classList.remove(cls));
                        this.dualNavigationSystem.isTransitioning = false;
                    }, 400);
                }, 400);
                
                console.log(`🎲 Navigated to face ${faceIndex}: ${this.geometryStates[faceIndex]}`);
                this.updateParameterDisplay();
            }
            
            triggerGeometryChange(geometryName, faceIndex) {
                // Trigger geometry change in visualizers like sophisticated system
                console.log(`🎨 Triggering geometry change: ${geometryName} (face ${faceIndex})`);
                
                if (this.hyperavCore && this.hyperavCore.setTheme) {
                    this.hyperavCore.setTheme(geometryName);
                }
                
                // Update CSS theme class
                document.body.className = `theme-${geometryName}`;
            }
            
            setTheme(themeName) {
                if (!this.hyperavCore || this.currentTheme === themeName) return;
                
                this.currentTheme = themeName;
                this.hyperavCore.setTheme(themeName);
                
                // Update body class for theme-specific CSS
                document.body.className = `theme-${themeName}`;
                
                this.updateParameterDisplay();
            }
            
            applyPreset(presetName) {
                const preset = this.configSystem.getConfig('behavior', `presets.${presetName}`);
                if (!preset) {
                    console.warn(`Preset '${presetName}' not found`);
                    return;
                }
                
                console.log(`🎨 Applying preset: ${presetName}`);
                
                // Apply parameters
                if (preset.parameters && this.hyperavCore) {
                    this.hyperavCore.updateParameters(preset.parameters);
                }
                
                // Apply section
                if (preset.section !== undefined) {
                    this.navigateToSection(preset.section);
                }
                
                // Apply theme
                if (preset.theme) {
                    this.setTheme(preset.theme);
                }
                
                this.updateParameterDisplay();
            }
            
            cycleFace() {
                const nextFace = (this.currentFace + 1) % this.geometryStates.length;
                this.navigateToFace(nextFace);
            }
            
            toggleDevMode() {
                const devControls = document.querySelector('.dev-controls');
                const paramDisplay = document.querySelector('.parameter-display');
                
                const isVisible = devControls.style.display !== 'none';
                const newDisplay = isVisible ? 'none' : 'block';
                
                devControls.style.display = newDisplay;
                paramDisplay.style.display = newDisplay;
                
                console.log(`🔧 Dev mode ${isVisible ? 'disabled' : 'enabled'}`);
            }
            
            updateParameterDisplay() {
                if (!this.hyperavCore) return;
                
                const params = this.hyperavCore.params;
                const geometryName = this.geometryStates[this.currentFace];
                
                // Find section name from geometry
                let sectionName = 'Unknown';
                for (const [key, modifier] of Object.entries(this.sectionModifiers)) {
                    if (modifier.geometryThemeName === geometryName) {
                        sectionName = modifier.name;
                        break;
                    }
                }
                
                document.getElementById('currentSection').textContent = sectionName;
                document.getElementById('currentTheme').textContent = geometryName;
                document.getElementById('currentDimension').textContent = params.dimension.toFixed(1);
                document.getElementById('currentGrid').textContent = params.gridDensity.toFixed(1);
                document.getElementById('currentMorph').textContent = params.morphFactor.toFixed(2);
                document.getElementById('currentIntensity').textContent = this.hyperavCore.interactionState.intensity.toFixed(2);
            }
            
            // VIB3HomeMaster interface methods
            registerVisualizer(name, visualizer) {
                console.log(`📝 Registered visualizer: ${name}`);
            }
            
            registerInteraction(type, intensity, duration) {
                // Handle interaction registration
            }
            
            transitionToSection(sectionIndex) {
                this.navigateToSection(sectionIndex);
            }
            
            onSectionChange(callback) {
                this.sectionChangeCallback = callback;
            }
            
            // UnifiedReactivityBridge interface methods
            syncShaderUniforms(uniforms) {
                // Handle shader uniform sync
            }
            
            triggerEffect(effectName, data) {
                console.log(`✨ Effect triggered: ${effectName}`, data);
            }
        }
        
        // Dev Controls Global Object
        window.devControls = {
            applyPreset: (presetName) => {
                if (window.vib3System) {
                    window.vib3System.applyPreset(presetName);
                }
            },
            
            cycleFace: () => {
                if (window.vib3System) {
                    window.vib3System.cycleFace();
                }
            },
            
            testParameterChange: () => {
                if (window.vib3System && window.vib3System.hyperavCore) {
                    window.vib3System.hyperavCore.updateParameters({
                        dimension: 4.2,
                        morphFactor: 1.0,
                        gridDensity: 20.0
                    });
                    window.vib3System.updateParameterDisplay();
                    
                    // Return to normal after 2 seconds
                    setTimeout(() => {
                        const currentThemeConfig = window.vib3System.hyperavCore.themeConfigs[window.vib3System.currentTheme];
                        if (currentThemeConfig) {
                            window.vib3System.hyperavCore.updateParameters(currentThemeConfig);
                            window.vib3System.updateParameterDisplay();
                        }
                    }, 2000);
                }
            }
        };
        
        // Initialize system when page loads
        window.addEventListener('load', () => {
            window.vib3System = new VIB3TesseractSystem();
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const canvas = document.getElementById('reactive-canvas');
            if (canvas) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
        });
        
        console.log('🌟 VIB3 Tesseract System script loaded');
    </script>
</body>
</html>