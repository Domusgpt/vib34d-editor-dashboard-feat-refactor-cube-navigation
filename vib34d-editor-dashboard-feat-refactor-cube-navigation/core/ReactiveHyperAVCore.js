/**
 * ReactiveHyperAVCore.js - Advanced WebGL 4D Visualization Engine
 * 
 * Implements sophisticated 4D polytope rendering with:
 * - 8 sacred geometries (hypercube, tetrahedron, sphere, torus, klein, fractal, wave, crystal)
 * - JSON-driven parameter configuration
 * - Real-time interaction responsiveness
 * - Mathematical parameter relationships
 * - Performance optimization and context pooling
 */

import ShaderManager from './ShaderManager.js';
import GeometryManager from './GeometryManager.js';
import ProjectionManager from './ProjectionManager.js';

class ReactiveHyperAVCore {
    constructor(canvas, options = {}) {
        this.canvas = canvas;
        this.gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if (!this.gl) {
            console.error('WebGL not supported for ReactiveHyperAVCore');
            throw new Error('WebGL not supported');
        }
        
        console.log('üé® ReactiveHyperAVCore initializing...');
        
        // Configuration system
        this.config = {
            visualsConfig: null,
            behaviorConfig: null,
            contentConfig: null,
            currentSection: 0,
            currentTheme: 'hypercube',
            ...options
        };
        
        // Core state
        this.startTime = Date.now();
        this.currentTheme = this.config.currentTheme;
        this.currentGeometry = 'hypercube';
        
        // Interaction state tracking
        this.interactionState = {
            type: 'idle',
            intensity: 0,
            lastActivity: Date.now(),
            holdStart: 0,
            isHolding: false,
            scrollVelocity: 0,
            mouseX: 0.5,
            mouseY: 0.5,
            dragActive: false,
            resizeActive: false
        };
        
        // Default parameters (overridden by JSON config)
        this.baseParameters = {\n            dimension: 3.5,\n            morphFactor: 0.5,\n            gridDensity: 12.0,\n            glitchIntensity: 0.3,\n            rotationSpeed: 0.5,\n            interactionIntensity: 0.0,\n            baseColor: [1.0, 0.0, 1.0],\n            accentColor: [0.0, 1.0, 1.0]\n        };\n        \n        // Current active parameters\n        this.activeParameters = { ...this.baseParameters };\n        \n        // Core rendering systems\n        this.shaderManager = null;\n        this.geometryManager = null;\n        this.projectionManager = null;\n        \n        // Geometry mapping for shader uniforms\n        this.geometryMap = {\n            'hypercube': 0, 'tetrahedron': 1, 'sphere': 2, 'torus': 3,\n            'kleinbottle': 4, 'fractal': 5, 'wave': 6, 'crystal': 7\n        };\n        \n        // Performance tracking\n        this.performance = {\n            frameCount: 0,\n            lastFrameTime: 0,\n            fps: 0,\n            renderTime: 0\n        };\n        \n        this.initializeSystems();\n        this.setupInteractions();\n        this.setupCanvas();\n        this.startRenderLoop();\n        \n        console.log('‚úÖ ReactiveHyperAVCore initialized');\n    }\n    \n    async initializeSystems() {\n        try {\n            // Initialize core rendering systems\n            this.shaderManager = new ShaderManager(this.gl);\n            this.geometryManager = new GeometryManager();\n            this.projectionManager = new ProjectionManager();\n            \n            // Load and compile default shader program\n            await this.createVisualizationProgram();\n            \n            // Initialize buffers\n            this.initBuffers();\n            \n            console.log('üîß Core rendering systems initialized');\n        } catch (error) {\n            console.error('‚ùå Failed to initialize rendering systems:', error);\n            throw error;\n        }\n    }\n    \n    async createVisualizationProgram() {\n        const vertexShaderSource = `\n            attribute vec2 a_position;\n            void main() {\n                gl_Position = vec4(a_position, 0.0, 1.0);\n            }\n        `;\n        \n        // Get current geometry and projection shader code\n        const geometry = this.geometryManager.getGeometry(this.currentGeometry);\n        const projection = this.projectionManager.getProjection('perspective');\n        \n        const fragmentShaderSource = `\n            precision highp float;\n            \n            uniform vec2 u_resolution;\n            uniform float u_time;\n            uniform vec2 u_mouse;\n            uniform float u_dimension;\n            uniform float u_morphFactor;\n            uniform float u_gridDensity;\n            uniform float u_glitchIntensity;\n            uniform float u_rotationSpeed;\n            uniform float u_interactionIntensity;\n            uniform vec3 u_baseColor;\n            uniform vec3 u_accentColor;\n            uniform float u_geometry;\n            \n            // 4D rotation matrices\n            mat4 rotXW(float theta) {\n                float c = cos(theta);\n                float s = sin(theta);\n                return mat4(c, 0, 0, -s, 0, 1, 0, 0, 0, 0, 1, 0, s, 0, 0, c);\n            }\n            \n            mat4 rotYW(float theta) {\n                float c = cos(theta);\n                float s = sin(theta);\n                return mat4(1, 0, 0, 0, 0, c, 0, -s, 0, 0, 1, 0, 0, s, 0, c);\n            }\n            \n            mat4 rotZW(float theta) {\n                float c = cos(theta);\n                float s = sin(theta);\n                return mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, c, -s, 0, 0, s, c);\n            }\n            \n            mat4 rotYZ(float theta) {\n                float c = cos(theta);\n                float s = sin(theta);\n                return mat4(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);\n            }\n            \n            // 4D to 3D projection\n            ${projection.getShaderCode()}\n            \n            // Geometry calculation\n            ${geometry.getShaderCode()}\n            \n            // Advanced geometry generators based on type\n            float getGeometryValue(vec3 p, float gridSize, float geomType) {\n                if (geomType < 0.5) {\n                    // Hypercube\n                    return calculateLattice(p);\n                } else if (geomType < 1.5) {\n                    // Tetrahedron  \n                    vec3 q = fract(p * gridSize) - 0.5;\n                    float d1 = length(q);\n                    float d2 = length(q - vec3(0.5, 0.0, 0.0));\n                    float d3 = length(q - vec3(0.0, 0.5, 0.0));\n                    float d4 = length(q - vec3(0.0, 0.0, 0.5));\n                    return 1.0 - smoothstep(0.0, 0.1, min(min(d1, d2), min(d3, d4)));\n                } else if (geomType < 2.5) {\n                    // Sphere\n                    vec3 q = fract(p * gridSize) - 0.5;\n                    float r = length(q);\n                    return 1.0 - smoothstep(0.2, 0.5, r);\n                } else if (geomType < 3.5) {\n                    // Torus\n                    vec3 q = fract(p * gridSize) - 0.5;\n                    float r1 = sqrt(q.x*q.x + q.y*q.y);\n                    float r2 = sqrt((r1 - 0.3)*(r1 - 0.3) + q.z*q.z);\n                    return 1.0 - smoothstep(0.0, 0.1, r2);\n                } else if (geomType < 4.5) {\n                    // Klein Bottle\n                    vec3 q = fract(p * gridSize);\n                    float u = q.x * 2.0 * 3.14159;\n                    float v = q.y * 2.0 * 3.14159;\n                    float x = cos(u) * (3.0 + cos(u/2.0) * sin(v) - sin(u/2.0) * sin(2.0*v));\n                    float klein = length(vec2(x, q.z)) - 0.1;\n                    return 1.0 - smoothstep(0.0, 0.05, abs(klein));\n                } else if (geomType < 5.5) {\n                    // Fractal\n                    vec3 q = p * gridSize;\n                    float scale = 1.0;\n                    float fractal = 0.0;\n                    for(int i = 0; i < 4; i++) {\n                        q = fract(q) - 0.5;\n                        fractal += abs(length(q)) / scale;\n                        scale *= 2.0;\n                        q *= 2.0;\n                    }\n                    return 1.0 - smoothstep(0.0, 1.0, fractal);\n                } else if (geomType < 6.5) {\n                    // Wave\n                    vec3 q = p * gridSize;\n                    float wave = sin(q.x * 2.0) * sin(q.y * 2.0) * sin(q.z * 2.0 + u_time);\n                    return smoothstep(-0.5, 0.5, wave);\n                } else {\n                    // Crystal\n                    vec3 q = fract(p * gridSize) - 0.5;\n                    float d = max(max(abs(q.x), abs(q.y)), abs(q.z));\n                    return 1.0 - smoothstep(0.3, 0.5, d);\n                }\n            }\n            \n            void main() {\n                vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n                float aspectRatio = u_resolution.x / u_resolution.y;\n                uv.x *= aspectRatio;\n                \n                vec2 center = vec2(u_mouse.x * aspectRatio, u_mouse.y);\n                vec3 p = vec3(uv - center, 0.0);\n                \n                // Interaction-driven rotation\n                float timeRotation = u_time * 0.2 * u_rotationSpeed * (1.0 + u_interactionIntensity);\n                mat2 rotation = mat2(cos(timeRotation), -sin(timeRotation), sin(timeRotation), cos(timeRotation));\n                p.xy = rotation * p.xy;\n                p.z = sin(u_time * 0.1) * 0.5;\n                \n                // Apply 4D transformations based on interaction\n                if (u_dimension > 3.0) {\n                    float w = sin(length(p) * 3.0 + u_time * 0.3) * (u_dimension - 3.0) * (1.0 + u_interactionIntensity * 0.5);\n                    vec4 p4d = vec4(p, w);\n                    \n                    p4d = rotXW(timeRotation * 0.31) * p4d;\n                    p4d = rotYW(timeRotation * 0.27) * p4d;\n                    p4d = rotZW(timeRotation * 0.23) * p4d;\n                    \n                    p = project4Dto3D(p4d);\n                }\n                \n                // Dynamic grid density based on interaction\n                float dynamicGridDensity = u_gridDensity * (1.0 + u_interactionIntensity * 0.3);\n                \n                // Get geometry value\n                float lattice = getGeometryValue(p, dynamicGridDensity, u_geometry);\n                \n                // Interaction-driven glitch effects\n                float glitchAmount = u_glitchIntensity * (0.1 + 0.1 * sin(u_time * 5.0)) * (1.0 + u_interactionIntensity);\n                \n                vec2 rOffset = vec2(glitchAmount, glitchAmount * 0.5);\n                vec2 gOffset = vec2(-glitchAmount * 0.3, glitchAmount * 0.2);\n                vec2 bOffset = vec2(glitchAmount * 0.1, -glitchAmount * 0.4);\n                \n                float r = getGeometryValue(vec3(p.xy + rOffset, p.z), dynamicGridDensity, u_geometry);\n                float g = getGeometryValue(vec3(p.xy + gOffset, p.z), dynamicGridDensity, u_geometry);\n                float b = getGeometryValue(vec3(p.xy + bOffset, p.z), dynamicGridDensity, u_geometry);\n                \n                // Base colors with theme-specific tinting\n                vec3 baseColor = vec3(0.02, 0.05, 0.1);\n                vec3 latticeColor = u_baseColor * (0.8 + 0.2 * u_interactionIntensity);\n                \n                vec3 color = mix(baseColor, latticeColor, vec3(r, g, b));\n                \n                // Interaction-responsive glow\n                color += u_baseColor * 0.1 * (0.5 + 0.5 * sin(u_time * 0.5)) * u_interactionIntensity;\n                \n                // Vignette\n                float vignette = 1.0 - smoothstep(0.4, 1.4, length(uv - vec2(center.x, center.y)));\n                color *= vignette;\n                \n                gl_FragColor = vec4(color, 0.95);\n            }\n        `;\n        \n        // Create shader program\n        this.program = this.shaderManager.createProgram('reactiveHyperAV', vertexShaderSource, fragmentShaderSource);\n        \n        if (!this.program) {\n            throw new Error('Failed to create reactive HyperAV shader program');\n        }\n        \n        // Get uniform locations\n        this.uniforms = {\n            resolution: this.gl.getUniformLocation(this.program, 'u_resolution'),\n            time: this.gl.getUniformLocation(this.program, 'u_time'),\n            mouse: this.gl.getUniformLocation(this.program, 'u_mouse'),\n            dimension: this.gl.getUniformLocation(this.program, 'u_dimension'),\n            morphFactor: this.gl.getUniformLocation(this.program, 'u_morphFactor'),\n            gridDensity: this.gl.getUniformLocation(this.program, 'u_gridDensity'),\n            glitchIntensity: this.gl.getUniformLocation(this.program, 'u_glitchIntensity'),\n            rotationSpeed: this.gl.getUniformLocation(this.program, 'u_rotationSpeed'),\n            interactionIntensity: this.gl.getUniformLocation(this.program, 'u_interactionIntensity'),\n            baseColor: this.gl.getUniformLocation(this.program, 'u_baseColor'),\n            accentColor: this.gl.getUniformLocation(this.program, 'u_accentColor'),\n            geometry: this.gl.getUniformLocation(this.program, 'u_geometry')\n        };\n        \n        this.positionAttributeLocation = this.gl.getAttribLocation(this.program, 'a_position');\n    }\n    \n    initBuffers() {\n        this.positionBuffer = this.gl.createBuffer();\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\n        this.gl.bufferData(\n            this.gl.ARRAY_BUFFER,\n            new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0]),\n            this.gl.STATIC_DRAW\n        );\n    }\n    \n    setupCanvas() {\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n        this.gl.clearColor(0.0, 0.0, 0.0, 1.0);\n    }\n    \n    setupInteractions() {\n        let lastScrollY = window.scrollY;\n        let lastScrollTime = Date.now();\n        \n        // Mouse movement tracking\n        this.canvas.addEventListener('mousemove', (e) => {\n            const rect = this.canvas.getBoundingClientRect();\n            this.interactionState.mouseX = (e.clientX - rect.left) / rect.width;\n            this.interactionState.mouseY = 1.0 - (e.clientY - rect.top) / rect.height;\n            this.interactionState.lastActivity = Date.now();\n            this.updateInteractionState('move', 0.3);\n        });\n        \n        // Click/Touch interactions\n        const startInteraction = (e) => {\n            this.interactionState.isHolding = true;\n            this.interactionState.holdStart = Date.now();\n            this.updateInteractionState('hold', 1.0);\n            e.preventDefault();\n        };\n        \n        const endInteraction = () => {\n            this.interactionState.isHolding = false;\n            this.updateInteractionState('release', 0.1);\n        };\n        \n        this.canvas.addEventListener('mousedown', startInteraction);\n        this.canvas.addEventListener('mouseup', endInteraction);\n        this.canvas.addEventListener('touchstart', startInteraction, { passive: false });\n        this.canvas.addEventListener('touchend', endInteraction);\n        \n        // Scroll tracking\n        window.addEventListener('scroll', () => {\n            const currentTime = Date.now();\n            const currentY = window.scrollY;\n            const deltaY = Math.abs(currentY - lastScrollY);\n            const deltaTime = currentTime - lastScrollTime;\n            \n            if (deltaTime > 0) {\n                this.interactionState.scrollVelocity = deltaY / deltaTime * 100;\n                this.updateInteractionState('scroll', Math.min(this.interactionState.scrollVelocity / 20, 1.0));\n            }\n            \n            lastScrollY = currentY;\n            lastScrollTime = currentTime;\n            this.interactionState.lastActivity = currentTime;\n        });\n        \n        // Inactivity detection\n        setInterval(() => {\n            const timeSinceActivity = Date.now() - this.interactionState.lastActivity;\n            if (timeSinceActivity > 3000) {\n                this.updateInteractionState('idle', 0.0);\n            }\n        }, 1000);\n    }\n    \n    updateInteractionState(type, intensity) {\n        this.interactionState.type = type;\n        this.interactionState.intensity = Math.max(this.interactionState.intensity * 0.9, intensity);\n        this.activeParameters.interactionIntensity = this.interactionState.intensity;\n    }\n    \n    // JSON Configuration Integration\n    loadVisualConfiguration(visualsConfig) {\n        this.config.visualsConfig = visualsConfig;\n        \n        if (visualsConfig.themes && visualsConfig.themes[this.currentTheme]) {\n            const themeConfig = visualsConfig.themes[this.currentTheme];\n            \n            // Apply theme parameters\n            Object.assign(this.activeParameters, themeConfig.parameters);\n            this.activeParameters.baseColor = themeConfig.baseColor || this.baseParameters.baseColor;\n            this.activeParameters.accentColor = themeConfig.accentColor || this.baseParameters.accentColor;\n            \n            console.log(`üé® Applied visual theme: ${this.currentTheme}`);\n        }\n    }\n    \n    loadBehaviorConfiguration(behaviorConfig) {\n        this.config.behaviorConfig = behaviorConfig;\n        \n        if (behaviorConfig.vib34dGeometries && behaviorConfig.vib34dGeometries[this.currentGeometry]) {\n            const geometryConfig = behaviorConfig.vib34dGeometries[this.currentGeometry];\n            Object.assign(this.activeParameters, geometryConfig.defaultParameters);\n            \n            console.log(`üîß Applied geometry behavior: ${this.currentGeometry}`);\n        }\n    }\n    \n    loadContentConfiguration(contentConfig) {\n        this.config.contentConfig = contentConfig;\n        this.config.currentSection = contentConfig.currentSection || 0;\n        \n        console.log(`üìÑ Applied content configuration for section: ${this.config.currentSection}`);\n    }\n    \n    // Theme and geometry switching\n    setTheme(themeName) {\n        if (!this.config.visualsConfig || !this.config.visualsConfig.themes[themeName]) {\n            console.warn(`Theme '${themeName}' not found in configuration`);\n            return;\n        }\n        \n        this.currentTheme = themeName;\n        const themeConfig = this.config.visualsConfig.themes[themeName];\n        \n        // Smooth transition to new theme\n        this.transitionToParameters(themeConfig.parameters);\n        this.activeParameters.baseColor = themeConfig.baseColor;\n        this.activeParameters.accentColor = themeConfig.accentColor;\n        \n        console.log(`üé® Theme changed to: ${themeName}`);\n    }\n    \n    setGeometry(geometryName) {\n        if (!this.geometryMap.hasOwnProperty(geometryName)) {\n            console.warn(`Geometry '${geometryName}' not supported`);\n            return;\n        }\n        \n        this.currentGeometry = geometryName;\n        \n        // Apply geometry-specific parameters if available\n        if (this.config.behaviorConfig && this.config.behaviorConfig.vib34dGeometries[geometryName]) {\n            const geometryConfig = this.config.behaviorConfig.vib34dGeometries[geometryName];\n            this.transitionToParameters(geometryConfig.defaultParameters);\n        }\n        \n        console.log(`üîß Geometry changed to: ${geometryName}`);\n    }\n    \n    transitionToParameters(targetParams, duration = 1000) {\n        const startParams = { ...this.activeParameters };\n        const startTime = Date.now();\n        \n        const transition = () => {\n            const elapsed = Date.now() - startTime;\n            const progress = Math.min(elapsed / duration, 1.0);\n            const eased = 0.5 - 0.5 * Math.cos(progress * Math.PI);\n            \n            Object.keys(targetParams).forEach(key => {\n                if (typeof targetParams[key] === 'number' && typeof startParams[key] === 'number') {\n                    this.activeParameters[key] = startParams[key] + (targetParams[key] - startParams[key]) * eased;\n                }\n            });\n            \n            if (progress < 1.0) {\n                requestAnimationFrame(transition);\n            }\n        };\n        \n        transition();\n    }\n    \n    updateParameters(newParams) {\n        Object.assign(this.activeParameters, newParams);\n    }\n    \n    resize() {\n        const displayWidth = this.canvas.clientWidth;\n        const displayHeight = this.canvas.clientHeight;\n        \n        if (this.canvas.width !== displayWidth || this.canvas.height !== displayHeight) {\n            this.canvas.width = displayWidth;\n            this.canvas.height = displayHeight;\n            this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n        }\n    }\n    \n    render() {\n        const startTime = performance.now();\n        \n        // Handle hold interactions (dimensional shift)\n        let holdEffect = 0;\n        if (this.interactionState.isHolding) {\n            const holdDuration = Date.now() - this.interactionState.holdStart;\n            holdEffect = Math.min(holdDuration / 2000, 1.0);\n        }\n        \n        const currentDimension = this.activeParameters.dimension + holdEffect * 0.5;\n        const currentGridDensity = this.activeParameters.gridDensity * (1.0 + this.interactionState.intensity * 0.2);\n        const geometryIndex = this.geometryMap[this.currentGeometry] || 0;\n        \n        // Clear and setup\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n        this.gl.useProgram(this.program);\n        \n        // Setup vertex attributes\n        this.gl.enableVertexAttribArray(this.positionAttributeLocation);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\n        this.gl.vertexAttribPointer(this.positionAttributeLocation, 2, this.gl.FLOAT, false, 0, 0);\n        \n        // Set uniforms\n        this.gl.uniform2f(this.uniforms.resolution, this.canvas.width, this.canvas.height);\n        this.gl.uniform1f(this.uniforms.time, (Date.now() - this.startTime) / 1000);\n        this.gl.uniform2f(this.uniforms.mouse, this.interactionState.mouseX, this.interactionState.mouseY);\n        this.gl.uniform1f(this.uniforms.dimension, currentDimension);\n        this.gl.uniform1f(this.uniforms.morphFactor, this.activeParameters.morphFactor);\n        this.gl.uniform1f(this.uniforms.gridDensity, currentGridDensity);\n        this.gl.uniform1f(this.uniforms.glitchIntensity, this.activeParameters.glitchIntensity);\n        this.gl.uniform1f(this.uniforms.rotationSpeed, this.activeParameters.rotationSpeed);\n        this.gl.uniform1f(this.uniforms.interactionIntensity, this.interactionState.intensity);\n        this.gl.uniform3fv(this.uniforms.baseColor, this.activeParameters.baseColor);\n        this.gl.uniform3fv(this.uniforms.accentColor, this.activeParameters.accentColor);\n        this.gl.uniform1f(this.uniforms.geometry, geometryIndex);\n        \n        // Draw\n        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);\n        \n        // Performance tracking\n        this.performance.renderTime = performance.now() - startTime;\n        this.performance.frameCount++;\n    }\n    \n    startRenderLoop() {\n        const animate = () => {\n            this.resize();\n            this.render();\n            \n            // Decay interaction intensity\n            this.interactionState.intensity *= 0.98;\n            this.activeParameters.interactionIntensity = this.interactionState.intensity;\n            \n            requestAnimationFrame(animate);\n        };\n        \n        animate();\n        console.log('üîÑ Render loop started');\n    }\n    \n    getSystemState() {\n        return {\n            currentTheme: this.currentTheme,\n            currentGeometry: this.currentGeometry,\n            activeParameters: { ...this.activeParameters },\n            interactionState: { ...this.interactionState },\n            performance: { ...this.performance },\n            canvasSize: { width: this.canvas.width, height: this.canvas.height }\n        };\n    }\n    \n    dispose() {\n        console.log('üßπ Disposing ReactiveHyperAVCore...');\n        \n        if (this.gl && !this.gl.isContextLost()) {\n            if (this.positionBuffer) {\n                this.gl.deleteBuffer(this.positionBuffer);\n            }\n            \n            if (this.shaderManager) {\n                this.shaderManager.dispose();\n            }\n        }\n        \n        this.canvas = null;\n        this.gl = null;\n        console.log('‚úÖ ReactiveHyperAVCore disposed');\n    }\n}\n\nexport default ReactiveHyperAVCore;