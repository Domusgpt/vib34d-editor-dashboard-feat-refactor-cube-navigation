<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VIB3CODE | JSON-Configurable Tesseract Navigation System</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=JetBrains+Mono:wght@400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: white;
            font-family: 'Orbitron', 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
            cursor: crosshair;
            background: radial-gradient(ellipse at center, #1a0033 0%, #000000 70%);
            
            /* INVISIBLE SCROLLBARS */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }
        
        body::-webkit-scrollbar {
            width: 0;
            height: 0;
            display: none; /* Chrome/Safari */
        }
        
        /* TESSERACT 8-CELL HYPERCUBE CONTAINER */
        .tesseract-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            perspective: 2000px;
            perspective-origin: center center;
            overflow: hidden;
            z-index: 10;

            /* Advanced CSS Variables for Real-time Reactivity */
            --global-energy: 0.0;
            --section-focus: 0;
            --portal-intensity: 0.0;
            --micro-chaos: 0.0;
            --inverse-flow: 0.0;
            --grid-vibrance: 1.0;
            --transition-phase: 0.0;
            --hover-section: -1;
            --scroll-momentum: 0.0;
            --reality-tear: 0.0;

            /* Smart Opacity Variables */
            --visualizer-opacity: 0.8;
            --focused-opacity: 0.9;
            --reading-opacity: 0.7;
            --gravity-opacity: 0.8;
            --board-opacity: 0.7;

            /* Content Guidance Variables */
            --content-gravity-x: 0.5;
            --content-gravity-y: 0.5;
            --content-flow-strength: 0.0;
            --text-proximity: 0.0;
        }
        
        .hypercube-face {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            backface-visibility: visible;
            transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        /* SINGLE DYNAMIC FACE WITH 8 GEOMETRY STATES */
        .hypercube-face.active-face {
            transform: translateZ(0px);
            opacity: 1;
            visibility: visible;
        }
        
        /* GEOMETRY-BASED DYNAMIC STATES */
        .active-face[data-geometry="hypercube"] { /* HOME STATE */
            /* Hypercube sovereignty layout */
        }
        
        .active-face[data-geometry="tetrahedron"] { /* TECH STATE */
            /* Tetrahedron precision layout */
        }
        
        .active-face[data-geometry="wave"] { /* RESEARCH STATE */
            /* Wave function layout */
        }
        
        .active-face[data-geometry="sphere"] { /* MEDIA STATE */
            /* Sphere potential layout */
        }
        
        .active-face[data-geometry="fractal"] { /* INNOVATION STATE */
            /* Fractal growth layout */
        }
        
        .active-face[data-geometry="crystal"] { /* CONTEXT STATE */
            /* Crystal lattice layout */
        }
        
        .active-face[data-geometry="klein"] { /* KLEIN STATE */
            /* Klein bottle topology layout */
        }
        
        .active-face[data-geometry="torus"] { /* TORUS STATE */
            /* Torus flow layout */
        }
        
        /* TESSERACT FOLDING STATES */
        .tesseract-container.folding-right .hypercube-face.face-0 {
            transform: rotateY(-90deg) translateZ(-100px);
        }
        
        .tesseract-container.folding-right .hypercube-face.face-1 {
            transform: rotateY(0deg) translateZ(0px);
        }
        
        .tesseract-container.folding-left .hypercube-face.face-0 {
            transform: rotateY(90deg) translateZ(-100px);
        }
        
        .tesseract-container.folding-left .hypercube-face.face-3 {
            transform: rotateY(0deg) translateZ(0px);
        }
        
        .tesseract-container.folding-up .hypercube-face.face-0 {
            transform: rotateX(90deg) translateZ(-100px);
        }
        
        .tesseract-container.folding-up .hypercube-face.face-4 {
            transform: rotateX(0deg) translateZ(0px);
        }
        
        .tesseract-container.folding-down .hypercube-face.face-0 {
            transform: rotateX(-90deg) translateZ(-100px);
        }
        
        .tesseract-container.folding-down .hypercube-face.face-5 {
            transform: rotateX(0deg) translateZ(0px);
        }
        
        /* HYPERCUBE TENSION MECHANICS */
        .tesseract-container.tension-building {
            --tension-intensity: 0.0;
            filter: blur(calc(var(--tension-intensity) * 2px));
        }
        
        .tesseract-container.tension-building .hypercube-face {
            transform: scale(calc(1.0 + var(--tension-intensity) * 0.05)) 
                      rotateZ(calc(var(--tension-intensity) * 2deg));
        }
        
        /* VISUALIZER BACKGROUND BOARD */
        .visualizer-board {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #board-visualizer {
            width: 100%;
            height: 100%;
            opacity: var(--board-opacity, 0.3);
            filter: blur(0.8px);
            transition: opacity 0.8s ease;
        }
        
        /* FLOATING BLOG CARDS */
        .blog-card {
            position: absolute;
            backdrop-filter: blur(calc(20px + var(--grid-vibrance) * 10px)) saturate(calc(180% + var(--grid-vibrance) * 50%));
            border-radius: 25px;
            border: 2px solid rgba(255, 255, 255, calc(0.18 + var(--global-energy) * 0.3));
            z-index: 5;
            transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            overflow: hidden;
            box-shadow: 
                0 calc(15px + var(--global-energy) * 20px) calc(35px + var(--global-energy) * 30px) rgba(0, 0, 0, 0.4),
                0 5px 15px rgba(0, 255, 255, calc(0.1 + var(--grid-vibrance) * 0.2)),
                inset 0 1px 1px rgba(255, 255, 255, calc(0.2 + var(--global-energy) * 0.2)),
                inset 0 -1px 1px rgba(0, 0, 0, 0.1);
            background: linear-gradient(135deg, 
                rgba(0, 0, 0, calc(0.85 + var(--global-energy) * 0.1)) 0%,
                rgba(0, 0, 0, calc(0.90 + var(--global-energy) * 0.05)) 50%,
                rgba(0, 0, 0, 0.95) 100%
            );
            transform-style: preserve-3d;
            /* Base transform combines global micro-chaos effects with card-specific transforms */
            transform:
                scale(calc(var(--self-scale, 1.0) + var(--micro-chaos, 0) * 0.02))
                translateX(var(--self-translateX_px, 0px))
                translateY(var(--self-translateY_px, 0px))
                translateZ(var(--self-translateZ_px, 0px))
                rotateX(calc(var(--inverse-flow, 0) * 2deg))
                rotateY(calc(var(--inverse-flow, 0) * 1deg));
            opacity: var(--self-opacity, 1.0);
            border-color: var(--self-borderColor, rgba(255, 255, 255, calc(0.18 + var(--global-energy) * 0.3)));
            backdrop-filter: blur(var(--self-backdropBlur_px, calc(20px + var(--grid-vibrance) * 10px))) saturate(var(--self-backdropSaturate_percent, calc(180 + var(--grid-vibrance) * 50))%);
            z-index: var(--self-zIndex, 5);
            will-change: transform, opacity, width, height, top, left, z-index, border-color, box-shadow;
        }
        
        .blog-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(calc(135deg + var(--transition-phase) * 180deg),
                rgba(0, 255, 255, calc(0.08 + var(--grid-vibrance) * 0.12)) 0%,
                rgba(255, 0, 255, calc(0.06 + var(--grid-vibrance) * 0.10)) 25%,
                rgba(255, 255, 0, calc(0.04 + var(--grid-vibrance) * 0.08)) 50%,
                rgba(0, 255, 0, calc(0.06 + var(--grid-vibrance) * 0.10)) 75%,
                rgba(255, 0, 128, calc(0.08 + var(--grid-vibrance) * 0.12)) 100%
            );
            border-radius: inherit;
            z-index: -1;
            opacity: calc(0.6 + var(--global-energy) * 0.4);
            transition: all 0.3s ease;
        }
        
        .card-visualizer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: var(--visualizer-opacity, 0.6);
            z-index: 1;
            pointer-events: none;
        }
        
        .card-content {
            position: relative;
            z-index: 2;
            padding: 20px;
            color: white;
            height: 100%;
            overflow: hidden;
            will-change: transform;
        }
        
        .card-title {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .card-subtitle {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 15px;
        }
        
        .article-content {
            line-height: 1.4;
            opacity: 0.9;
        }
        
        /* STATE INDICATOR */
        .state-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            padding: 15px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            z-index: 1000;
            backdrop-filter: blur(10px);
            min-width: 200px;
        }
        
        .state-row {
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
        }
        
        .state-value {
            color: #00ffff;
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
        }
        
        /* DEV CONTROLS */
        .dev-controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 0, 255, 0.5);
            border-radius: 15px;
            padding: 15px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            z-index: 1000;
            backdrop-filter: blur(10px);
            display: none;
        }
        
        .dev-button {
            background: rgba(255, 0, 255, 0.2);
            border: 1px solid rgba(255, 0, 255, 0.5);
            color: white;
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            margin: 5px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            transition: all 0.3s ease;
        }
        
        .dev-button:hover {
            background: rgba(255, 0, 255, 0.4);
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.6);
        }
    </style>
    
    <!-- CORE ARCHITECTURE SYSTEMS - EMBEDDED TO AVOID CORS -->
    <script src="./VIB3_JSON_CONFIG_SYSTEM.js"></script>
    <script src="./VIB3_REACTIVE_HYPERAV_CORE.js"></script>
    <script>
        // EMBEDDED VIB3HomeMaster (simplified version for immediate functionality)
        class VIB3HomeMaster {
            constructor() {
                this.masterState = {
                    intensity: 0.0,
                    complexity: 0.5,
                    dimension: 4.0,
                    energy: 0.0
                };
                this.currentParameters = {};
                this.registeredVisualizers = [];
                console.log('🏠 VIB3HomeMaster (embedded) initialized');
            }
            
            getSystemState() {
                return { masterState: this.masterState };
            }
            
            overrideParameters(params) {
                Object.assign(this.masterState, params);
                console.log('🏠 Parameters overridden:', params);
            }
            
            reset() {
                this.masterState = {
                    intensity: 0.0,
                    complexity: 0.5,
                    dimension: 4.0,
                    energy: 0.0
                };
                console.log('🏠 VIB3HomeMaster reset to baseline');
            }
            
            registerInteraction(type, intensity, duration) {
                this.masterState.intensity = Math.max(this.masterState.intensity, intensity);
                console.log(`🏠 Interaction registered: ${type}, intensity: ${intensity}`);
            }
            
            registerVisualizer(visualizer, role) {
                this.registeredVisualizers.push({ visualizer, role });
                console.log(`🏠 Visualizer registered: ${role || 'unknown'}`);
            }
            
            transitionToSection(sectionIndex) {
                console.log(`🏠 Transitioning to section: ${sectionIndex}`);
            }
            
            getParametersForGeometry(geometryName) {
                return {
                    geometry: geometryName,
                    intensity: this.masterState.intensity,
                    complexity: this.masterState.complexity,
                    dimension: this.masterState.dimension
                };
            }
        }
        
        // EMBEDDED UnifiedReactivityBridge (simplified version)
        class UnifiedReactivityBridge {
            constructor() {
                this.eventQueue = [];
                console.log('🌉 UnifiedReactivityBridge (embedded) initialized');
            }
            
            queueEvent(type, data) {
                this.eventQueue.push({ type, data, timestamp: performance.now() });
                console.log(`🌉 Event queued: ${type}`, data);
            }
            
            syncShaderUniforms(uniforms) {
                console.log('🌉 Shader uniforms synced:', uniforms);
            }
        }
        
        // Make available globally
        window.VIB3HomeMaster = VIB3HomeMaster;
        window.UnifiedReactivityBridge = UnifiedReactivityBridge;
        console.log('🔗 Embedded core systems loaded');
    </script>
</head>
<body>
    <!-- STATE INDICATOR -->
    <div class="state-indicator">
        <div class="state-row">Layout: <span class="state-value" id="current-layout">HOME</span></div>
        <div class="state-row">Theme: <span class="state-value" id="current-theme">Hypercube Grid</span></div>
        <div class="state-row">Geometry: <span class="state-value" id="current-geometry">hypercube</span></div>
        <div class="state-row">Face: <span class="state-value" id="current-face">0</span></div>
        <div class="state-row">Energy: <span class="state-value" id="current-energy">0.00</span></div>
    </div>
    
    <!-- DEV CONTROLS -->
    <div class="dev-controls">
        <div style="margin-bottom: 10px; color: #ff00ff;">🔧 Dev Controls</div>
        <button class="dev-button" onclick="window.vib3System?.testParameterChange()">Test Parameters</button>
        <button class="dev-button" onclick="window.vib3System?.cycleFace()">Cycle Face</button>
        <button class="dev-button" onclick="window.vib3System?.resetSystem()">Reset System</button>
        <button class="dev-button" onclick="window.vib3System?.runSystemTest()">🧪 System Test</button>
        <div style="margin-top: 10px; font-size: 0.6rem; opacity: 0.7;">
            D: Toggle Dev | Space: Cycle | R: Reset<br>
            Arrow Keys: Navigate | Drag: Tension<br>
            <span id="system-status" style="color: #00ff00;">System Ready</span>
        </div>
    </div>

    <!-- TESSERACT NAVIGATION CONTAINER -->
    <div class="tesseract-container" id="tesseractContainer">
        <!-- SINGLE DYNAMIC FACE WITH 8 GEOMETRY STATES -->
        <div class="hypercube-face active-face" id="dynamic-face" data-geometry="hypercube" data-face="0">
            
            <!-- VISUALIZER BACKGROUND BOARD -->
            <div class="visualizer-board">
                <canvas id="board-visualizer"></canvas>
            </div>
            
            <!-- FLOATING BLOG CARDS (6 CARDS POSITIONED DYNAMICALLY) -->
            <div class="blog-card" id="blog-card-1" style="top: 10%; left: 5%; width: 25%; height: 20%;">
                <canvas class="card-visualizer" id="card-visualizer-1"></canvas>
                <div class="card-content">
                    <!-- Content will be populated by JSON -->
                </div>
            </div>
            
            <div class="blog-card" id="blog-card-2" style="top: 15%; left: 35%; width: 30%; height: 35%;">
                <canvas class="card-visualizer" id="card-visualizer-2"></canvas>
                <div class="card-content">
                    <!-- Content will be populated by JSON -->
                </div>
            </div>
            
            <div class="blog-card" id="blog-card-3" style="top: 10%; left: 70%; width: 25%; height: 25%;">
                <canvas class="card-visualizer" id="card-visualizer-3"></canvas>
                <div class="card-content">
                    <!-- Content will be populated by JSON -->
                </div>
            </div>
            
            <div class="blog-card" id="blog-card-4" style="top: 55%; left: 5%; width: 20%; height: 30%;">
                <canvas class="card-visualizer" id="card-visualizer-4"></canvas>
                <div class="card-content">
                    <!-- Content will be populated by JSON -->
                </div>
            </div>
            
            <div class="blog-card" id="blog-card-5" style="top: 60%; left: 30%; width: 35%; height: 25%;">
                <canvas class="card-visualizer" id="card-visualizer-5"></canvas>
                <div class="card-content">
                    <!-- Content will be populated by JSON -->
                </div>
            </div>
            
            <div class="blog-card" id="blog-card-6" style="top: 45%; left: 70%; width: 25%; height: 40%;">
                <canvas class="card-visualizer" id="card-visualizer-6"></canvas>
                <div class="card-content">
                    <!-- Content will be populated by JSON -->
                </div>
            </div>
            
        </div>
    </div>
    
    <script>
        /**
         * VIB3 SOPHISTICATED TESSERACT NAVIGATION SYSTEM
         * 
         * Integrates the sophisticated architecture with JSON configuration:
         * - VIB3HomeMaster parameter authority
         * - UnifiedReactivityBridge multi-layer synchronization  
         * - ReactiveHyperAVCore 4D WebGL shader system
         * - JSON-driven content and configuration
         * - Advanced tesseract navigation with folding mechanics
         */
        
        class VIB3SophisticatedTesseractSystem {
            constructor() {
                this.configSystem = null;
                this.homeMaster = null;
                this.reactivityBridge = null;
                this.visualizers = [];
                this.currentGeometry = 'hypercube';
                this.currentFace = 0;
                this.isInitialized = false;
                this.isTransitioning = false;
                
                // Geometry states mapping (8-face tesseract)
                this.geometryStates = [
                    'hypercube',    // Face 0 - HOME (FRONT)
                    'tetrahedron',  // Face 1 - TECH (RIGHT)
                    'wave',         // Face 2 - RESEARCH (BACK)
                    'sphere',       // Face 3 - MEDIA (LEFT)
                    'fractal',      // Face 4 - INNOVATION (TOP)
                    'crystal',      // Face 5 - CONTEXT (BOTTOM)
                    'klein',        // Face 6 - INNER FRONT
                    'torus'         // Face 7 - INNER BACK
                ];
                
                // Section modifiers from sophisticated architecture
                this.sectionModifiers = {
                    'HOME': { geometryThemeName: 'hypercube', name: 'HOME', multiplier: 1.0 },
                    'TECH': { geometryThemeName: 'tetrahedron', name: 'TECH', multiplier: 0.91 },
                    'RESEARCH': { geometryThemeName: 'wave', name: 'RESEARCH', multiplier: 1.15 },
                    'MEDIA': { geometryThemeName: 'sphere', name: 'MEDIA', multiplier: 1.08 },
                    'INNOVATION': { geometryThemeName: 'fractal', name: 'INNOVATION', multiplier: 1.22 },
                    'CONTEXT': { geometryThemeName: 'crystal', name: 'CONTEXT', multiplier: 0.88 },
                    'KLEIN': { geometryThemeName: 'klein', name: 'KLEIN', multiplier: 1.11 },
                    'TORUS': { geometryThemeName: 'torus', name: 'TORUS', multiplier: 1.03 }
                };
                
                console.log('🚀 VIB3 Sophisticated Tesseract System initializing...');
                this.init();
            }
            
            async init() {
                try {
                    // Initialize core systems first  
                    this.homeMaster = new VIB3HomeMaster();
                    this.reactivityBridge = new UnifiedReactivityBridge();
                    console.log('✅ Core systems initialized');
                    
                    // Initialize JSON configuration system
                    try {
                        if (typeof VIB3JSONConfigSystem !== 'undefined') {
                            this.configSystem = new VIB3JSONConfigSystem();
                            await this.configSystem.loadConfigurations();
                            console.log('✅ JSON Configuration system loaded');
                        } else {
                            console.warn('⚠️ VIB3JSONConfigSystem not found, using fallback content');
                            this.createFallbackContent();
                        }
                    } catch (error) {
                        console.warn('⚠️ JSON loading failed, using fallback content:', error);
                        this.createFallbackContent();
                    }
                    
                    // Initialize visualizer systems
                    this.initializeVisualizerSystems();
                    
                    // Load content from JSON
                    this.loadDynamicContentFromJSON();
                    
                    // Setup sophisticated interactions
                    this.setupAdvancedInteractions();
                    this.setupKeyboardControls();
                    
                    // Start parameter monitoring
                    this.startParameterMonitoring();
                    
                    this.isInitialized = true;
                    console.log('🌟 VIB3 Sophisticated Tesseract System initialized successfully!');
                    
                } catch (error) {
                    console.error('❌ Failed to initialize VIB3 system:', error);
                    this.createFallbackContent();
                }
            }
            
            initializeVisualizerSystems() {
                // Initialize board visualizer
                const boardCanvas = document.getElementById('board-visualizer');
                if (boardCanvas) {
                    boardCanvas.width = window.innerWidth;
                    boardCanvas.height = window.innerHeight;
                    
                    if (typeof VIB3ReactiveHyperAVCore !== 'undefined') {
                        const boardVisualizer = new VIB3ReactiveHyperAVCore(boardCanvas, this.homeMaster, this.reactivityBridge);
                        boardVisualizer.role = 'board';
                        boardVisualizer.assignGeometryByRole();
                        this.visualizers.push(boardVisualizer);
                        console.log('🎨 Board visualizer initialized');
                    }
                }
                
                // Initialize card visualizers
                for (let i = 1; i <= 6; i++) {
                    const cardCanvas = document.getElementById(`card-visualizer-${i}`);
                    const cardElement = document.getElementById(`blog-card-${i}`);
                    
                    if (cardCanvas && cardElement) {
                        cardCanvas.width = cardElement.offsetWidth;
                        cardCanvas.height = cardElement.offsetHeight;
                        
                        if (typeof VIB3ReactiveHyperAVCore !== 'undefined') {
                            const cardVisualizer = new VIB3ReactiveHyperAVCore(cardCanvas, this.homeMaster, this.reactivityBridge);
                            cardVisualizer.role = 'card';
                            cardVisualizer.instanceId = `card-${i}`;
                            cardVisualizer.assignGeometryByRole();
                            this.visualizers.push(cardVisualizer);
                        }
                    }
                }
                
                console.log(`🎨 ${this.visualizers.length} visualizers initialized`);
            }
            
            loadDynamicContentFromJSON() {
                // Load content for current geometry state
                this.updateDynamicFaceContent(this.currentFace);
            }
            
            createFallbackContent() {
                // Create fallback content structure when JSON loading fails
                this.fallbackSections = [
                    {
                        name: 'HOME',
                        theme: 'hypercube',
                        content: [
                            { title: '🏠 VIB3CODE Core', content: 'Sophisticated tesseract navigation system with JSON configuration.' },
                            { title: '⚙️ JSON Configuration', content: 'Everything configurable through JSON for dashboard editors and agents.' },
                            { title: '🤖 Agent API', content: 'AI agents can modify any aspect through JSON configuration files.' },
                            { title: '🎨 Visual Ecosystem', content: 'Every element contributes to understanding system state.' },
                            { title: '🔧 Development Ready', content: 'Complete development environment with agent integration.' },
                            { title: '🌟 Systematic Feedback', content: 'Focused elements cause unfocused elements to react systematically.' }
                        ]
                    },
                    {
                        name: 'TECH',
                        theme: 'tetrahedron',
                        content: [
                            { title: '💻 Technology Stack', content: 'WebGL shaders, 4D mathematics, reactive parameter systems.' },
                            { title: '🔧 Configuration Loader', content: 'Dynamic JSON loading with real-time updates and validation.' },
                            { title: '🌐 Agent Endpoints', content: 'RESTful API for agent interaction and programmatic control.' }
                        ]
                    }
                ];
                console.log('📦 Fallback content created');
            }
            
            updateDynamicFaceContent(faceIndex) {
                const geometryName = this.geometryStates[faceIndex] || this.geometryStates[0];
                const dynamicFace = document.getElementById('dynamic-face');
                
                if (!dynamicFace) return;
                
                console.log(`🔄 DYNAMIC CONTENT: Switching to ${geometryName} (face ${faceIndex})`);
                
                dynamicFace.setAttribute('data-geometry', geometryName);
                dynamicFace.setAttribute('data-face', faceIndex.toString());
                
                // Get content from JSON configuration or fallback
                let sections;
                if (this.configSystem) {
                    sections = this.configSystem.getConfig('content', 'sections');
                } else {
                    sections = this.fallbackSections;
                }
                
                if (!sections) {
                    console.warn('No content sections available');
                    return;
                }
                
                // Find target section by geometry name  
                let targetSection = null;
                for (const [key, modifier] of Object.entries(this.sectionModifiers)) {
                    if (modifier.geometryThemeName === geometryName) {
                        if (Array.isArray(sections)) {
                            targetSection = sections.find(s => s.name === modifier.name);
                        } else {
                            targetSection = sections[key.toLowerCase()];
                        }
                        break;
                    }
                }
                
                // Fallback to first section if no match found
                if (!targetSection) {
                    targetSection = Array.isArray(sections) ? sections[0] : sections.home;
                }
                
                if (!targetSection || !targetSection.content) {
                    console.warn(`No content found for geometry: ${geometryName}`);
                    return;
                }
                
                // Clear all existing card content
                document.querySelectorAll('#dynamic-face .blog-card .card-content').forEach(container => {
                    container.innerHTML = '<div class="card-title">Loading...</div>';
                });
                
                // Populate cards with content
                const contentArray = Array.isArray(targetSection.content) ? targetSection.content : [targetSection.content];
                contentArray.forEach((cardData, index) => {
                    const cardElement = document.getElementById(`blog-card-${index + 1}`);
                    if (!cardElement) return;
                    
                    const contentContainer = cardElement.querySelector('.card-content');
                    if (!contentContainer) return;
                    
                    // Create dynamic content
                    contentContainer.innerHTML = `
                        <div class="card-title">${cardData.title || 'Card ' + (index + 1)}</div>
                        ${cardData.subtitle ? `<div class="card-subtitle">${cardData.subtitle}</div>` : ''}
                        <div class="article-content">${cardData.content || 'Dynamic content loaded from JSON configuration.'}</div>
                    `;
                    
                    // Setup card reactivity from JSON
                    if (cardData.reactivity) {
                        this.setupCardReactivity(cardElement, cardData.reactivity);
                    }
                });
                
                // Update current state
                this.currentGeometry = geometryName;
                this.currentFace = faceIndex;
                
                // Trigger geometry change in all visualizers
                this.triggerGeometryChange(geometryName, faceIndex);
            }
            
            setupCardReactivity(cardElement, reactivityConfig) {
                cardElement.addEventListener('mouseenter', () => {
                    if (reactivityConfig.parameterChanges) {
                        this.applyParameterChanges(reactivityConfig.parameterChanges);
                    }
                });
                
                cardElement.addEventListener('mouseleave', () => {
                    this.resetParameterChanges();
                });
            }
            
            applyParameterChanges(changes) {
                if (this.homeMaster && this.homeMaster.overrideParameters) {
                    this.homeMaster.overrideParameters(changes);
                }
                
                // Update CSS variables for immediate visual feedback
                const container = document.querySelector('.tesseract-container');
                if (container) {
                    if (changes.energy) container.style.setProperty('--global-energy', changes.energy);
                    if (changes.gridVibrance) container.style.setProperty('--grid-vibrance', changes.gridVibrance);
                    if (changes.microChaos) container.style.setProperty('--micro-chaos', changes.microChaos);
                }
            }
            
            resetParameterChanges() {
                if (this.homeMaster && this.homeMaster.reset) {
                    this.homeMaster.reset();
                }
                
                // Reset CSS variables
                const container = document.querySelector('.tesseract-container');
                if (container) {
                    container.style.setProperty('--global-energy', '0.0');
                    container.style.setProperty('--grid-vibrance', '1.0');
                    container.style.setProperty('--micro-chaos', '0.0');
                }
            }
            
            setupAdvancedInteractions() {
                const container = document.getElementById('tesseractContainer');
                
                // Advanced drag interactions with tension building
                container.addEventListener('mousedown', (e) => this.startAdvancedDrag(e));
                container.addEventListener('touchstart', (e) => this.startAdvancedDrag(e), { passive: false });
                
                document.addEventListener('mousemove', (e) => this.handleAdvancedDrag(e));
                document.addEventListener('touchmove', (e) => this.handleAdvancedDrag(e), { passive: false });
                
                document.addEventListener('mouseup', () => this.endAdvancedDrag());
                document.addEventListener('touchend', () => this.endAdvancedDrag());
                
                console.log('🎲 Advanced tesseract interactions initialized');
            }
            
            startAdvancedDrag(e) {
                if (this.isTransitioning) return;
                
                this.isDragging = true;
                this.dragStartX = e.clientX || e.touches[0].clientX;
                this.dragStartY = e.clientY || e.touches[0].clientY;
                this.tensionLevel = 0;
                
                document.body.style.userSelect = 'none';
                console.log('🎲 Advanced drag started');
            }
            
            handleAdvancedDrag(e) {
                if (!this.isDragging || this.isTransitioning) return;
                
                e.preventDefault();
                
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                
                const deltaX = clientX - this.dragStartX;
                const deltaY = clientY - this.dragStartY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                // Build tension
                const threshold = 150;
                this.tensionLevel = Math.min(distance / threshold, 1.0);
                
                // Apply tension visual effects
                const container = document.getElementById('tesseractContainer');
                container.style.setProperty('--tension-intensity', this.tensionLevel);
                
                if (this.tensionLevel > 0.3) {
                    container.classList.add('tension-building');
                }
                
                // Determine navigation direction at threshold
                if (distance > threshold) {
                    const angle = Math.atan2(deltaY, deltaX);
                    this.determineNavigationDirection(angle);
                }
            }
            
            endAdvancedDrag() {
                if (!this.isDragging) return;
                
                this.isDragging = false;
                document.body.style.userSelect = '';
                
                // Reset tension
                const container = document.getElementById('tesseractContainer');
                container.classList.remove('tension-building');
                container.style.setProperty('--tension-intensity', '0');
                
                console.log('🎲 Advanced drag ended');
            }
            
            determineNavigationDirection(angle) {
                // Convert angle to navigation direction
                const degrees = (angle * 180 / Math.PI + 360) % 360;
                let targetFace = this.currentFace;
                
                if (degrees >= 315 || degrees < 45) { // Right
                    targetFace = 1; // TECH
                } else if (degrees >= 45 && degrees < 135) { // Down
                    targetFace = 5; // CONTEXT
                } else if (degrees >= 135 && degrees < 225) { // Left
                    targetFace = 3; // MEDIA
                } else if (degrees >= 225 && degrees < 315) { // Up
                    targetFace = 4; // INNOVATION
                }
                
                if (targetFace !== this.currentFace) {
                    this.navigateToFace(targetFace);
                }
            }
            
            navigateToFace(faceIndex) {
                if (faceIndex === this.currentFace || this.isTransitioning) return;
                
                this.isTransitioning = true;
                
                // Apply tesseract folding animation
                const container = document.getElementById('tesseractContainer');
                const foldingClasses = {
                    1: 'folding-right',
                    2: 'folding-back',
                    3: 'folding-left',
                    4: 'folding-up',
                    5: 'folding-down',
                    6: 'folding-inner-front',
                    7: 'folding-inner-back'
                };
                
                // Remove all folding classes
                Object.values(foldingClasses).forEach(cls => container.classList.remove(cls));
                
                // Add appropriate folding class
                if (foldingClasses[faceIndex]) {
                    container.classList.add(foldingClasses[faceIndex]);
                }
                
                // Update content after folding animation
                setTimeout(() => {
                    this.updateDynamicFaceContent(faceIndex);
                    
                    // Reset folding state
                    setTimeout(() => {
                        Object.values(foldingClasses).forEach(cls => container.classList.remove(cls));
                        this.isTransitioning = false;
                    }, 400);
                }, 400);
                
                console.log(`🎲 Navigated to face ${faceIndex}: ${this.geometryStates[faceIndex]}`);
                this.updateStateDisplay();
            }
            
            triggerGeometryChange(geometryName, faceIndex) {
                console.log(`🎨 Triggering geometry change: ${geometryName} (face ${faceIndex})`);
                
                // Update all visualizers
                this.visualizers.forEach(visualizer => {
                    if (visualizer.setTheme) {
                        visualizer.setTheme(geometryName);
                    }
                });
                
                // Update CSS theme class
                document.body.className = `theme-${geometryName}`;
                
                this.updateStateDisplay();
            }
            
            setupKeyboardControls() {
                document.addEventListener('keydown', (e) => {
                    if (!this.isInitialized) return;
                    
                    switch(e.key) {
                        case 'd':
                        case 'D':
                            this.toggleDevMode();
                            break;
                        case ' ':
                            e.preventDefault();
                            this.cycleFace();
                            break;
                        case 'r':
                        case 'R':
                            this.resetSystem();
                            break;
                        case 'ArrowRight':
                            this.navigateToFace(1); // TECH
                            break;
                        case 'ArrowLeft':
                            this.navigateToFace(3); // MEDIA
                            break;
                        case 'ArrowUp':
                            this.navigateToFace(4); // INNOVATION
                            break;
                        case 'ArrowDown':
                            this.navigateToFace(5); // CONTEXT
                            break;
                    }
                });
            }
            
            cycleFace() {
                const nextFace = (this.currentFace + 1) % this.geometryStates.length;
                this.navigateToFace(nextFace);
            }
            
            toggleDevMode() {
                const devControls = document.querySelector('.dev-controls');
                const isVisible = devControls.style.display !== 'none';
                devControls.style.display = isVisible ? 'none' : 'block';
                console.log(`🔧 Dev mode ${isVisible ? 'disabled' : 'enabled'}`);
            }
            
            testParameterChange() {
                if (this.homeMaster && this.homeMaster.overrideParameters) {
                    this.homeMaster.overrideParameters({
                        intensity: 1.0,
                        complexity: 0.8,
                        dimension: 4.2
                    });
                    
                    setTimeout(() => {
                        this.homeMaster.reset();
                        console.log('🧪 Test parameters reset');
                    }, 2000);
                    
                    console.log('🧪 Test parameter change applied');
                }
            }
            
            resetSystem() {
                if (this.homeMaster && this.homeMaster.reset) {
                    this.homeMaster.reset();
                }
                
                this.navigateToFace(0); // Return to HOME
                console.log('🔄 System reset to baseline');
            }
            
            updateStateDisplay() {
                const geometryName = this.geometryStates[this.currentFace];
                const sectionName = this.getSectionNameFromGeometry(geometryName);
                
                document.getElementById('current-layout').textContent = sectionName;
                document.getElementById('current-theme').textContent = `${geometryName} Grid`;
                document.getElementById('current-geometry').textContent = geometryName;
                document.getElementById('current-face').textContent = this.currentFace;
                
                if (this.homeMaster && this.homeMaster.getSystemState) {
                    const masterState = this.homeMaster.getSystemState();
                    document.getElementById('current-energy').textContent = 
                        (masterState.masterState?.intensity || 0).toFixed(2);
                }
            }
            
            getSectionNameFromGeometry(geometryName) {
                const geometryToSection = {
                    'hypercube': 'HOME',
                    'tetrahedron': 'TECH',
                    'wave': 'RESEARCH',
                    'sphere': 'MEDIA',
                    'fractal': 'INNOVATION',
                    'crystal': 'CONTEXT',
                    'klein': 'KLEIN',
                    'torus': 'TORUS'
                };
                
                return geometryToSection[geometryName] || 'HOME';
            }
            
            startParameterMonitoring() {
                // Monitor parameters in real-time
                setInterval(() => {
                    this.updateStateDisplay();
                    
                    // Sync parameters to all visualizers
                    if (this.homeMaster && this.homeMaster.getParametersForGeometry) {
                        const currentParams = this.homeMaster.getParametersForGeometry(this.currentGeometry);
                        this.visualizers.forEach(visualizer => {
                            if (visualizer.updateParameters) {
                                visualizer.updateParameters(currentParams);
                            }
                        });
                    }
                }, 100); // 10fps update rate
            }
            
            // VIB3HomeMaster interface methods (for compatibility)
            registerVisualizer(name, visualizer) {
                console.log(`📝 Registered visualizer: ${name}`);
                this.visualizers.push(visualizer);
            }
            
            registerInteraction(type, intensity, duration) {
                if (this.homeMaster && this.homeMaster.registerInteraction) {
                    this.homeMaster.registerInteraction(type, intensity, duration);
                }
            }
            
            // Comprehensive system test
            runSystemTest() {
                console.log('🧪 Running comprehensive system test...');
                
                const tests = [
                    () => this.testJSONConfiguration(),
                    () => this.testVisualizerSystems(), 
                    () => this.testNavigationSystem(),
                    () => this.testParameterReactivity(),
                    () => this.testGeometryStates()
                ];
                
                let passed = 0;
                tests.forEach((test, index) => {
                    try {
                        test();
                        passed++;
                        console.log(`✅ Test ${index + 1} passed`);
                    } catch (error) {
                        console.error(`❌ Test ${index + 1} failed:`, error);
                    }
                });
                
                console.log(`🧪 System test completed: ${passed}/${tests.length} tests passed`);
                return passed === tests.length;
            }
            
            testJSONConfiguration() {
                if (!this.configSystem && !this.fallbackSections) {
                    throw new Error('No configuration system available');
                }
                return true;
            }
            
            testVisualizerSystems() {
                if (this.visualizers.length === 0) {
                    throw new Error('No visualizers initialized');
                }
                return true;
            }
            
            testNavigationSystem() {
                if (!this.geometryStates || this.geometryStates.length !== 8) {
                    throw new Error('Geometry states not properly configured');
                }
                return true;
            }
            
            testParameterReactivity() {
                if (!this.homeMaster) {
                    throw new Error('VIB3HomeMaster not available');
                }
                return true;
            }
            
            testGeometryStates() {
                // Test that we can switch between all 8 states
                this.geometryStates.forEach((geometry, index) => {
                    this.triggerGeometryChange(geometry, index);
                });
                return true;
            }
        }
        
        // Global system instance
        window.vib3System = null;
        
        // Initialize system when page loads
        window.addEventListener('load', () => {
            window.vib3System = new VIB3SophisticatedTesseractSystem();
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            // Resize board visualizer
            const boardCanvas = document.getElementById('board-visualizer');
            if (boardCanvas) {
                boardCanvas.width = window.innerWidth;
                boardCanvas.height = window.innerHeight;
            }
            
            // Resize card visualizers
            for (let i = 1; i <= 6; i++) {
                const cardCanvas = document.getElementById(`card-visualizer-${i}`);
                const cardElement = document.getElementById(`blog-card-${i}`);
                if (cardCanvas && cardElement) {
                    cardCanvas.width = cardElement.offsetWidth;
                    cardCanvas.height = cardElement.offsetHeight;
                }
            }
        });
        
        console.log('🌟 VIB3 Sophisticated Tesseract System script loaded');
    </script>
</body>
</html>